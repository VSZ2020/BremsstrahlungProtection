using BSP.BL.Calculation;
using BSP.BL.Services;
using BSP.Geometries.SDK;
using BSP.Linux.Main.Common;
using System.Collections.Generic;
using System.Threading.Tasks;
using System.Threading;
using System;
using System.Linq;
using System.ComponentModel.DataAnnotations;
using Microsoft.Extensions.DependencyInjection;
using System.Numerics;
using ReactiveUI;
using System.Reactive;
using System.Diagnostics;

namespace BSP.Linux.Main.ViewModels;

public class MainWindowViewModel : BaseNotificationViewModel
{
    public MainWindowViewModel(): this(
        App.Provider.GetRequiredService<RadionuclidesService>(),
        App.Provider.GetRequiredService<MaterialsService>(),
        App.Provider.GetRequiredService<DoseFactorsService>()) {}

    public MainWindowViewModel(RadionuclidesService radionuclidesService, MaterialsService materialsService, DoseFactorsService dcfService)
    {
        DataController = new AvailableDataController(radionuclidesService, materialsService);

        TabSource = new(radionuclidesService);
        TabShielding = new();
        TabBuildup = new();
        TabDoseFactors = new(dcfService);
        TabOutput = new();

        _progress = new Progress<double>((i) => ProgressValue = i);

        AboutCommand = ReactiveCommand.Create(() => ShowAboutWindow());
        UserManualCommand = ReactiveCommand.Create(ShowUserManual);
        ChangelogCommand = ReactiveCommand.Create(ShowChangelog);
    }

    private CancellationTokenSource _tokenSource;
    private IProgress<double> _progress;

    private double _progressValue;
    public double ProgressValue { get => _progressValue; set => this.RaiseAndSetIfChanged(ref _progressValue, value); }

    private string _resultsText = string.Empty;
    public string ResultsText { get => _resultsText; set => this.RaiseAndSetIfChanged(ref _resultsText, value); }

    private bool _isEvaluationInProgress = false;
    public bool IsEvaluationInProgress { get => _isEvaluationInProgress; set => this.RaiseAndSetIfChanged(ref _isEvaluationInProgress, value); }

    public TabSourceVM TabSource { get; }
    public TabShieldingVM TabShielding { get; }
    public TabBuildupVM TabBuildup { get; }
    public TabDoseFactorsVM TabDoseFactors { get; }
    public TabOutputVM TabOutput { get; }

    public AvailableDataController DataController { get; }

    public ReactiveCommand<Unit,Unit> AboutCommand { get; }
    public ReactiveCommand<Unit, Unit> UserManualCommand { get; }
    public ReactiveCommand<Unit, Unit> ChangelogCommand { get; }

    #region ValidateInputs
    /// <summary>
    /// Валидация входных данных формы
    /// </summary>
    /// <returns></returns>
    public bool ValidateInputs()
    {
        base.ClearValidationMessages();

        if (TabSource.UserRadionuclides.Count == 0 && TabSource.IsAutoGeneratedModeChecked)
            base.AddError("No one radionuclide was selected for calculations");

        if (TabSource.SourceDimensions.Select(d => d.Discreteness).Count(d => d == 0) > 0)
            base.AddError("Dimension discreteness should be greated zero");

        if (TabSource.SourceDimensions.Select(d => d.Value).Count(d => d == 0) > 0)
            base.AddError("Dimension should be greated zero");

        if (TabSource.EnergyYieldData.Count == 0)
            base.AddError("Energy and Yield data are empty. Click update to generate data or enter it manually");

        if (TabSource.TotalSourceActivity < 1)
            base.AddError("Source total activity is zero or empty");

        if (TabOutput.Precision <= 0)
            base.AddError("Number of decimal places is less or equal zero");

        var sourceWidth = GeometryService.GetSubstractionTermForAirgapCalculation(TabSource.SelectedSourceForm.FormType, TabSource.SourceDimensions.Select(d => d.Value).ToArray());
        var shieldsWidth = TabShielding.ShieldLayers.Select(l => l.D).Sum();
        var totalWidth = sourceWidth + shieldsWidth;
        if (TabOutput.DosePoints.Any(dp => dp.X <= totalWidth))
            base.AddError("Coordinate X of dose point is inside source and shielding");

        if (TabOutput.DosePoints.Count == 0)
            base.AddError("At least one dose point must to be");

        if (TabOutput.DosePoints.Any(p => p.X < 0 || p.Y < 0 || p.Z < 0))
            base.AddError("Dose point coordinates are positive values");


        if (TabSource.SourceDimensions.Count > 0)
        {
            if (TabOutput.DosePoints.Any(p => p.X <= TabSource.SourceDimensions.First().Value))
                base.AddError("Dose point on the edge or inside source volume");

            if (TabSource.SourceDimensions.Count > 1 && TabOutput.DosePoints.Any(p => p.X <= 0) && TabOutput.DosePoints.Any(p => p.Y <= TabSource.SourceDimensions[1].Value))
                base.AddError("Y coordinate of dose point on the edge or inside source volume");

            if (TabSource.SourceDimensions.Count > 2 && TabOutput.DosePoints.Any(p => p.X <= 0) && TabOutput.DosePoints.Any(p => p.Z <= TabSource.SourceDimensions[2].Value))
                base.AddError("Z coordinate of dose point on the edge or inside source volume");
        }

        return IsValid;
    }
    #endregion

    #region GetBuilder
    private InputDataBuilder GetBuilder(double[] energies, double[] bremsstrahlungEnergyFluxes)
    {
        //Обновляем экземпляр токена отмены операции
        _tokenSource = new CancellationTokenSource();

        var shields = TabShielding.ShieldLayers.Select(l => new ShieldLayer()
        {
            Id = l.Id,
            Z = l.Z,
            D = l.D,
            Name = l.Name,
            Weight = l.Weight,
            Density = l.Density,
        }).ToList();

        //Добавляем последним слоем слой среды
        shields.Add(new ShieldLayer()
        {
            Id = TabOutput.SelectedEnvironmentMaterial!.Id,
            Density = TabOutput.SelectedEnvironmentMaterial.Density,
        });

        //Выбираем идентификаторы слоев защиты
        var shieldLayersIds = shields.Select(s => s.Id).ToArray();

        var builder = App.Provider.GetRequiredService<InputDataBuilder>()
                .WithDimensions(
                    TabSource.SourceDimensions.Select(d => d.Value).ToArray(),
                    TabSource.SourceDimensions.Select(d => d.Discreteness).ToArray())
                .WithEnergies(energies)
                .WithShieldLayers(shields)
                .WithAttenuationFactors(TabSource.SelectedSourceMaterial.Id, shieldLayersIds, energies)
                .WithEnvironmentAbsorptionFactors(energies, TabOutput.SelectedEnvironmentMaterial?.Id ?? 1)
                .WithBremsstrahlungEnergyFluxes(bremsstrahlungEnergyFluxes)
                .WithBuildup(
                    TabBuildup.SelectedBuildup.BuildupType,
                    TabBuildup.IsIncludeBuildup ? TabBuildup.SelectedComplexBuildup.BuildupType : null,
                    TabSource.SelectedSourceMaterial.Id,
                    shieldLayersIds, energies)
                .WithSourceDensity(TabSource.SourceMaterialDensity)
                .WithSourceActivity(TabSource.TotalSourceActivity)
                .WithCancellationToken(_tokenSource.Token)
                .WithProgress(_progress)
                .WithSelfabsorption(!TabOutput.IsSelfAbsorptionOff);
        return builder;
    }
    #endregion

    #region GetDoseFactors
    private double[] GetDoseFactors(double[] energies)
    {
        return App.Provider.GetRequiredService<DoseFactorsService>().GetDoseConversionFactors(
                TabDoseFactors.SelectedDoseFactorType.DoseFactorType,
                energies,
                TabDoseFactors.SelectedExposureGeometry.Id,
                TabDoseFactors.SelectedOrganTissue.Id);
    }
    #endregion

    #region ButtonStartClicked
    public async void ButtonStartClicked(object item)
    {
        base.ShowStatusMessage("Validation in progress");
        //Блокируем интерфейс
        IsEvaluationInProgress = true;
        ResetProgress();

        if (ValidateInputs())
        {
            await EvaluateByPointAsync();

            base.ShowStatusMessage("Completed!");
        }
        else
        {
            ShowStatusMessage("There are inputs errors!");
            var msgs = base.ValidationMessagesToString();
            base.ShowMessageBox("Calculation can't be launched due to error(s):" + "\n" + msgs, "Validation errors");
        }

        ResetProgress();
        IsEvaluationInProgress = false;
    }

    public bool CanButtonStartClicked(object item)
    {
        return !_isEvaluationInProgress;
    }
    #endregion

    #region StopCalculation
    public void ButtonAbortClicked()
    {
        this._tokenSource.Cancel();
        ShowStatusMessage("Cancelled by user");
    }

    public bool CanButtonAbortClicked(object item)
    {
        return _isEvaluationInProgress;
    }
    #endregion

    #region EvaluateByPointAsync
    private async Task EvaluateByPointAsync(InputDataBuilder? builder = null, bool isMutedOutput = false)
    {
        //Данные по спектру тормозного излучения
        (double[] energies, double[] bremsstrahlungEnergyFluxes) = TabSource.GetBremsstrahlungSpectrum();

        if (builder == null)
            builder = GetBuilder(energies, bremsstrahlungEnergyFluxes);

        var doseFactors = GetDoseFactors(energies);

        var dimensions = TabSource.SourceDimensions.Select(d => d.Value).ToArray();
        var formProcessor = GeometryService.GetGeometryInstance(TabSource.SelectedSourceForm.FormType);
        var airgapSubstractionTerm = GeometryService.GetSubstractionTermForAirgapCalculation(TabSource.SelectedSourceForm.FormType, dimensions);
        var shieldsTotalLengthWithoutAirgap = TabShielding.ShieldLayers.Select(l => l.D).Sum();

        var dosePointsResults = new List<OutputValue>();
        //Выполняем расчет для каждой точки регистрации излучения
        var targetPoints = TabOutput.DosePoints.Select(p => new Vector3(p.X, p.Y, p.Z)).ToArray();
        foreach (var point in targetPoints)
        {
            base.ShowStatusMessage(string.Format("Evaluation for dose point ({0},{1},{2})", point.X, point.Y, point.Z));
            var input = builder
                .WithCalculationPoint(point)
                .Build();

            //Рассчитываем толщину слоя воздуха
            input.Layers.Last().D = point.X - shieldsTotalLengthWithoutAirgap - airgapSubstractionTerm;

            _progress?.Report(0);
            var results = await Calculation.StartAsync(input, formProcessor);

            if (input.CancellationToken.IsCancellationRequested)
            {
                isMutedOutput = true;
                break;
            }

            results.PartialAirKerma = results.ConvertToAnotherDose(doseFactors);
            dosePointsResults.Add(results);
        }

        if (!isMutedOutput)
            FillOutputTable(dosePointsResults, TabOutput.Precision);
    }
    #endregion

    #region FillOutputTable
    private void FillOutputTable(List<OutputValue> results, int precise = 3)
    {
        if (_tokenSource.IsCancellationRequested)
        {
            return;
        }

        string dosePointFormat = "({0},{1},{2})";
        //CalculationDate   Form    Material    Distance    DoseRate    Units
        string generalFormat = "{0,-20:dd.MM.yyyy HH:mm}{1,-30}{2,30}{3,20}{4,15:e" + precise + "} {5}\n";

        //Energy    FluxDensity     EnergyFluxDensity   DoseRate    Units
        string partialDataFormat = "{0:e" + precise + "}\t{1:e" + precise + "}\t{2:e" + precise + "}\t{3:e" + precise + "}\t{4}\n";

        //Запрашиваем единицы измерения дозы
        var units = DoseFactorsService.GetUnits(TabDoseFactors.SelectedDoseFactorType.DoseFactorType);
        units += "/h";

        //Заполняем заголовок результатов
        ReportResults(
            string.Format(generalFormat,
            "Launch time",
            "Form",
            "Source Material",
            "Dose point",
            "Dose rate",
            ""));

        foreach (var result in results)
        {
            ReportResults(
                string.Format(generalFormat,
                    DateTime.Now,
                    TabSource.SelectedSourceForm.Name,
                    TabSource.SelectedSourceMaterial.Name,
                    string.Format(dosePointFormat, result.DosePoint.X, result.DosePoint.Y, result.DosePoint.Z),
                    result.TotalDoseRate,
                    units));

            if (TabOutput.IsShowPartialDoseRates)
            {
                ReportResults(string.Format(partialDataFormat,
                    "Energy, MeV",
                    "Flux Density, 1/cm2/s",
                    "Energy Flux Density, MeV/cm2/s",
                    "Dose rate",
                    ""));

                for (var i = 0; i < result.PartialAirKerma.Length; i++)
                {
                    ReportResults(
                        string.Format(partialDataFormat,
                        result.Energies[i],
                        result.PartialFluxDensity[i],
                        result.PartialFluxDensity[i] * result.Energies[i],
                        result.PartialAirKerma[i],
                        units));
                }
            }
        }
        ReportResults("\n");
    }
    #endregion

    public void ResetProgress()
    {
        _progress?.Report(0);
    }

    public void ReportResults(string message)
    {
        ResultsText += message;
    }

    internal void ShowAboutWindow()
    {

    }

    internal void ShowChangelog()
    {
        if (System.IO.File.Exists("Changelog.txt"))
            Process.Start(new ProcessStartInfo() { UseShellExecute = true, FileName = "Changelog.txt" });
    }

    internal void ShowUserManual()
    {

    }
}